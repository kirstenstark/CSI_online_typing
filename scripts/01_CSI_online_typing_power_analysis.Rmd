---
title: "Power Analysis for CSI online typing"
author: "Kirsten Stark"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# load packages
```{r}
library(dplyr)
library(tidyr)
library(devtools)
library(MASS)
library(lme4)
library(lmerTest)
library(simr)
library(pbkrtest)
library(testthat)
library(ggplot2)

rm(list = ls())
```


# load data
```{r}
today <- Sys.Date()
today <- format(today, format="%d%m%y")

df <- read.csv(here::here("data", "pretest_long_correct.csv")) 
```


# 1) Set up models based on structure of the experimental data frame (pretest data)
````{r}
# subset the relevant columns
model_df <- df %>% 
  dplyr::select(c(subject, PosOr, category, timing.01)) %>% 
  filter(category != "Filler") %>%
  filter(!is.na(PosOr)) %>%
  dplyr::rename(RT = timing.01)
model_df <- droplevels(model_df)

# factorize columns
is.numeric(model_df$RT)
model_df$subject <- as.factor(model_df$subject)
model_df$PosOr <- as.factor(model_df$PosOr)
model_df$category <- as.factor(model_df$category)

# set contrasts
contrasts(model_df$PosOr) <- contr.poly(n = 5)
fixef_terms <- model.matrix( ~ PosOr,model_df) 
model_df$PosOr.L <- fixef_terms[,2]
```

```{r}
# check distribution of RTs (by eyeballing)
# 1) density plot of RTs
qplot(data=model_df, RT, geom="density", na.rm=TRUE)+ theme_bw() 
# 2) plot data against real normal distribution -> is it way off?
qqnorm(model_df$RT); qqline(model_df$RT)

# check distribution of logRTs (by eyeballing)
model_df$lRT <- log(model_df$RT)
# 1) density plot of logRTs
qplot(data=model_df, lRT, geom="density", na.rm=TRUE)+ theme_bw() 
# 2) plot data against real normal distribution -> is it way off?
qqnorm(model_df$lRT); qqline(model_df$lRT)
### data not really normally distributed ?!?!
```

```{r}
# Model 1: Linear model with untransformed RT data
lmm1 <- lmer(RT ~ PosOr.L + (1|subject) +(1|category) , 
            data =model_df, REML = FALSE)
summary(lmm1)

# Model 2: Linear model with log transformed RT data
lmm1_log <- lmer(lRT ~ PosOr.L + (1|subject) +(1|category) , 
            data =model_df, REML = FALSE)
summary(lmm1_log)

# Model 3: Generalized linear model with gamma distribution
glmm1 <- glmer(RT ~ PosOr.L+ (1|subject) +(1|category) , 
            data =model_df, family =Gamma(link ="identity"),
            control=glmerControl(optimizer = "bobyqa"))
# model has convergence warnings: is singular
isSingular(glmm1)
summary(glmm1)
# # try with the lme4 package only: exclude the random effect that explains the least variance
# glmm1 <- glmer(RT ~ PosOr.L + (PosOr.L|subject) +(PosOr.L|category) ,
#              data = model_df, family =Gamma(link ="identity"), control=glmerControl(optimizer = "bobyqa"))
# isSingular(glmm1)
# # model converges so we use this
# summary(glmm1)


# Model 3: compute GLMM
# glmm1 <- glmer(RT ~ PosOr + (PosOr|subject) +(PosOr|category) , 
#              data = model_df, family =Gamma(link ="identity"), control=glmerControl(optimizer = "bobyqa"))
# isSingular(glmm1)
# model does not converge with random slope ordinal position of subjects (is singular)

# -> drop correlations between fixed effects (Bates et al., 2015)
# CAVE: because the random effect PosOr is a factor, we need to use the # function lmer_alt from the afex package
#lmer_alt is a wrapper for mixed that behaves like g/lmer (glmer if #family argument is given), but allows the use of || with factors
# glmm1 <- afex::lmer_alt(RT ~ PosOr + (PosOr||subject) +(PosOr||category) , 
#              data = model_df, family =Gamma(link ="identity"), control=glmerControl(optimizer = "bobyqa"))
# isSingular(glmm1)
# # model converges so we use this
# summary(glmm1)
```

#2) Extend dataset
```{r}
lmm1 <- extend(lmm1, along="subject", n=100)
m2data <- getData(lmm1) 
## ok, data were indeed extended to n subjects ;-)
str(m2data)
str(model_df)

lmm1_log <- extend(lmm1_log, along="subject", n=40)
m2data <- getData(lmm1_log) 
## ok, data were indeed extended to n subjects ;-)
str(m2data)
str(model_df)

glmm1<- extend(glmm1, along="subject", n=40)
m2data <- getData(glmm1) 
## ok, data were indeed extended to n subjects ;-)
str(m2data)
str(model_df)
```

#3) Specify effect size: 15 ms (as in the online experiment)
We set the size of the fixed effect of interest, PosOr.L (linear trend of the ordinal position), and leave the random effects and residuals as is. 
We use the size of the fixed effect that we found in Experiment 1, the online verbal CSI experiment: 15 ms
```{r}
fixef(lmm1)
fixef(lmm1)["PosOr.L"] <- 30

fixef(lmm1_log)
fixef(lmm1_log)["PosOr.L"] <- 0.031

fixef(glmm1)
fixef(glmm1)["PosOr.L"] <- 30
```

#4) Run the power analysis
1) Linear model
```{r power analysis LMM untransformed RTs}
set.seed(27)
#doTest(lmm1, fixed("PosOr.L"))
powerSim(lmm1, test=fixed("PosOr.L","t"), nsim = 50) # increase to nsim > 1000 for real test
lastResult()$warnings
lastResult()$errors
```
2) Log linear model
```{r power analysis LMM log-transformed RTs}
set.seed(27)
#doTest(lmm1, fixed("PosOr.L"))
powerSim(lmm1_log, test=fixed("PosOr.L","t"), nsim = 1000) # increase to nsim > 1000 for real test
lastResult()$warnings
lastResult()$errors
```

3) GLMM
```{r power analysis GLMM}
set.seed(27)
doTest(glmm1, fixed("PosOr.L"))
powerSim(glmm1, test=fixed("PosOr.L","t"), nsim = 50) # increase to nsim > 1000 for real test
lastResult()$warnings
lastResult()$errors
```

# 5) Power analyses at a range of sample sizes
Unconverted RTs
```{r}
pc1_linear <- powerCurve(lmm1, breaks = c(30, 40, 50, 60, 70, 80, 90, 100),
                  nsim = 50) # increase nsim for real power analysis
print(pc_1)
```
Log-transformed RTs
```{r}
pc1_log <- powerCurve(lmm1_log, breaks = c(30, 35, 40, 50, 60, 70),
                  nsim = 50) # increase nsim for real power analysis
print(pc_1)
```

Gamma distribution (GLMM)
```{r}
pc1_glmm1 <- powerCurve(glmm1, breaks = c(30, 35, 40, 50, 60, 70),
                  nsim = 50) # increase nsim for real power analysis
print(pc_1)
```

ToDos: do the same but with correlation parameters!


```{r}
# # set typing to NA when first typed letter is enter or backspace
# df <- df %>% mutate(timing.01 = 
#                       ifelse(letters.01 == "Enter" |
#                                letters.01 == "Backspace", 
#                              NA, timing.01))
# 
# # subset the relevant columns
# model_df <- df %>% 
#   dplyr::select(c(subject, PosOr, category, timing.01)) %>% 
#   filter(category != "Filler") %>%
#   rename(RT = timing.01)
# model_df <- droplevels(model_df)
# 
# # factorize columns
# model_df$subject <- as.factor(model_df$subject)
# model_df$PosOr <- as.factor(model_df$PosOr)
# model_df$category <- as.factor(model_df$category)
# 
# # set contrasts of factor PosOr: polynomial contrasts
# contrasts(model_df$PosOr) <- contr.poly(n = 5)
# fixef_terms <- model.matrix( ~ PosOr,model_df) 
# model_df$PosOr.L <- fixef_terms[,2]
# 
# # check distribution of RTs (by eyeballing)
# # 1) density plot of RTs
# qplot(data=model_df, RT, geom="density", na.rm=TRUE)+ theme_bw() 
# # 2) plot data against real normal distribution -> is it way off?
# qqnorm(model_df$RT); qqline(model_df$RT)
# 
# # check distribution of logRTs (by eyeballing)
# model_df$lRT <- log(model_df$RT)
# # 1) density plot of logRTs
# qplot(data=model_df, lRT, geom="density", na.rm=TRUE)+ theme_bw() 
# # 2) plot data against real normal distribution -> is it way off?
# qqnorm(model_df$lRT); qqline(model_df$lRT)
# ### data not really normally distributed ?!?!
# 
# 
# # Model 1: Linear model with untransformed RT data
# lmm1 <- lmer(RT ~ PosOr.L + (1|subject) +(1|category) , 
#             data =model_df, REML = FALSE)
# summary(lmm1)
# 
# # Model 2: Linear model with log transformed RT data
# lmm1_log <- lmer(lRT ~ PosOr.L + (1|subject) +(1|category) , 
#             data =model_df, REML = FALSE)
# summary(lmm1_log)
# 
# # Model 3: Generalized linear model with gamma distribution
# glmm1 <- glmer(RT ~ PosOr.L+ (1|subject) +(PosOr.L|category) , 
#             data =model_df, family =Gamma(link ="identity"),
#             control=glmerControl(optimizer = "bobyqa"))
# summary(glmm1)
# 


# model_df_small$lRT <- log(model_df_small$RT)
# ### btw here's how to check normal distribution by eyeballing, just in case:
# qplot(data=model_df_small, RT, geom="density", na.rm=TRUE)+ theme_bw() # density plot log-RT
# normplot2 <- qqnorm(model_df_small$RT); qqline(model_df_small$RT) ### plot data points against real normal distribution as a line; is it way off?
#  ### kinda normally distributed except for a couple of outliers -> we might want to define outlier criteria and drop these trials
# 
# lmm1 <- lmer(RT ~ OrdPos.L + (1|VPNr) +(OrdPos.L|UCatName) , 
#             data =model_df_small, REML = FALSE)
# summary(lmm1)
# 
# lmm1_log <- lmer(lRT ~ OrdPos.L + (1|VPNr) +(OrdPos.L|UCatName) , 
#             data =model_df_small, REML = FALSE)
# 
# summary(lmm1_log)
# 
# ## glmm
# 
# glmm1 <- glmer(RT ~ OrdPos.L+ (1|VPNr) +(OrdPos.L|UCatName) , 
#             data =model_df_small, family =Gamma(link ="identity"), control=glmerControl(optimizer = "bobyqa"))
# summary(glmm1)



```


# Extend dataset
```{r}
# lmm2 <- extend(lmm1, along="subject", n=40)
# 
# m2data <- getData(lmm2) 
# ## ok, data were indeed extended to n subjects ;-)
# str(m2data)
# str(model_df)
```

# Power analysis for the linear trend (lmm1)
```{r}
# fixef(lmm1)
# 
# # now whip out your table containing the effect sizes you want to assume
#   ## enter the expected effect size (regression beta-weight) 
#   ## of the fixed effect in question
#   ## if testing an interaction, it does make a difference what the
#   ## effect sizes of the main effects are, so try to also get somewhat
#   ## realistic effect sizes for the main effects and enter them here.
#   ## Ideally based on previous studies or a pilot study 
#   ## Very small main effects will
#   ## increase the power for detecting a larger interaction effect
#    
#     
# fixef(lmm2)["PosOr.L"] <- 30# set effect size as the beta weight you want to assume for this fixed effect
#   
# # did it work?
# fixef(lmm2)
#    
# # doTest will just give you the t- and p-value of the fixed effect in
# # the non-simulated, but extended data; maybe not a necessary step
#  doTest(lmm2, fixed("PosOr.L", "t"))
# 
# ## simulate and estimate power of the extended model
# powerSim(lmm2, test=fixed("PosOr.L","t"), nsim=50) ## nsim should be 500 - 1000 for the real thing (will take a long time)
# 
#   #### errors during simulation? these can be displayed:
#   lastResult()$errors
#   # warnings?
#   lastResult()$warnings
#   
# pc2 <- powerCurve(lmm2)
# 
# print(pc2)
# 
# 
# ## simulate and estimate power of the original model          
# powerSim(lmm1, test=fixed("OrdPos.L","t"), nsim=50)
# 
# 
# powerSim(glmm1) 

```

## OrdPos as continuous variable, centered
```{r}
# model_df_small$OrdPos_cont <- as.numeric(model_df_small$OrdPos)
# str(model_df_small)
# 
# lmm1_cont_log <- lmer(lRT ~ scale(OrdPos_cont) + (scale(OrdPos_cont)|VPNr) +(scale(OrdPos_cont)|UCatName) , 
#             data =model_df_small, REML = FALSE)
# 
# summary(lmm1_cont_log)
# VarCorr(lmm1_cont_log)
# summary(rePCA(lmm1_cont_log)) # take out RE from VPNr
# 
# lmm1_cont_log2 <- lmer(lRT ~ scale(OrdPos_cont) + (1|VPNr) +(scale(OrdPos_cont)|UCatName) , 
#             data =model_df_small, REML = FALSE)
# summary(lmm1_cont_log2)
# 
# 
# lmm1_cont <- lmer(RT ~ scale(OrdPos_cont) + (1|VPNr) +(scale(OrdPos_cont)|UCatName) , 
#             data =model_df_small, REML = FALSE)
# summary(lmm1_cont)

```

# power analysis continuous
```{r}
# ##### with log ########
# 
# lmm2_cont_log <- extend(lmm1_cont_log2, along="VPNr", n=40) # extend to 40 subjects
# 
# m2data_cont_log <- getData(lmm2_cont) 
# str(m2data_cont_log) ## ok, data were indeed extended to n subjects ;-)
# 
# fixef(lmm1_cont_log2)
# fixef(lmm2_cont_log)["scale(OrdPos_cont)"] <- 0.031 
# 
# ## simulate and estimate power of the extended model
# powersim_40_cont_log <- powerSim(lmm2_cont_log, test=fixed("scale(OrdPos_cont)","t"), nsim=50) 
# 
# ## simulate and estimate power of the original model
# powersim_24_cont_log <- powerSim(lmm1_cont_log2, test=fixed("scale(OrdPos_cont)","t"), nsim=50)
# 
# 
# ## with smaller effect of log = 0.015
#     
# fixef(lmm2_cont_log)["scale(OrdPos_cont)"] <- 0.015
# fixef(lmm1_cont_log2)["scale(OrdPos_cont)"] <- 0.015
# 
# # did it work?
# fixef(lmm2_cont_log)
# 
# ## simulate and estimate power of the extended model
# powersim_40_cont_log_015 <- powerSim(lmm2_cont_log, test=fixed("scale(OrdPos_cont)","t"), nsim=50) 
# 
# ## simulate and estimate power of the original model
# powersim_24_cont_log_015 <- powerSim(lmm1_cont_log2, test=fixed("scale(OrdPos_cont)","t"), nsim=50) #
# 
# #### errors during simulation? these can be displayed:
# lastResult()$errors
# # warnings?
# lastResult()$warnings
# 
# 
# ##### without log ######
#   
# lmm2_cont <- extend(lmm1_cont, along="VPNr", n=40) # extend to 40 subjects
# 
# m2data_cont <- getData(lmm2_cont) 
# str(m2data_cont) ## ok, data were indeed extended to n subjects ;-)
# 
# fixef(lmm1_cont)
# 
# fixef(lmm2_cont)["scale(OrdPos_cont)"] <- 32.2# set effect size as the beta weight you want to assume for this fixed effect
#   
# # did it work?
# fixef(lmm2_cont)
#    
# # doTest will just give you the t- and p-value of the fixed effect in the
# # non-simulated, but extended data; maybe not a necessary step
#  doTest(lmm2_cont, fixed("scale(OrdPos_cont)", "t"))
# 
# ## simulate and estimate power of the extended model
# powersim_40_cont <- powerSim(lmm2_cont, test=fixed("scale(OrdPos_cont)","t"), nsim=50) ## nsim should be 500 - 1000 for the real thing (will take a long time)
# 
# ## simulate and estimate power of the original model
# powersim_24_cont <- powerSim(lmm1_cont, test=fixed("scale(OrdPos_cont)","t"), nsim=50) ## nsim should be 500 - 1000 for the real thing (will take a long time)
# 
# ## with 18ms
# 
# fixef(lmm2_cont)["scale(OrdPos_cont)"] <- 18 # set effect size at 18ms
# 
# powersim_40_cont_18ms <- powerSim(lmm2_cont, test=fixed("scale(OrdPos_cont)","t"), nsim=50)
# 
# fixef(lmm1_cont)["scale(OrdPos_cont)"] <- 18 # set effect size at 18ms
# 
# powersim_24_cont_18ms <- powerSim(lmm1_cont, test=fixed("scale(OrdPos_cont)","t"), nsim=50)
# 
# 
# ### with 30 participants
# 
# lmm3_cont <- extend(lmm1_cont, along="VPNr", n=30) # extend to 30 subjects
# 
# fixef(lmm3_cont)["scale(OrdPos_cont)"] <- 18
# fixef(lmm3_cont)
# 
# powersim_30_cont_18ms <- powerSim(lmm3_cont, test=fixed("scale(OrdPos_cont)","t"), nsim=50)


```

# write results

```{r}
# powersim_results_cont <- rbind(summary(powersim_40_cont_log),
#                           summary(powersim_24_cont_log), 
#                           summary(powersim_40_cont_log_015),
#                           summary(powersim_24_cont_log_015),
#                           summary(powersim_40_cont),
#                           summary(powersim_24_cont),
#                           summary(powersim_40_cont_18ms),
#                           summary(powersim_24_cont_18ms),
#                           summary(powersim_30_cont_18ms))
#                           
# powersim_results_cont <- cbind(powersim_results_cont, n = c(40,24,40,24,40,24,40,24,30), RT_transform = c("log","log","log","log","no","no","no","no","no"),Effect = c("0.031","0.031","0.015","0.015","32.2ms","32.2ms","18ms","18ms","18ms"))
# 
# write.table(powersim_results_cont, "powersim_results_cont.csv", append = FALSE, sep = ";", row.names = FALSE, col.names = TRUE)

```

