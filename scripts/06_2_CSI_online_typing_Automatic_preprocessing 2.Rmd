---
title: '06 CSI online typing: Automatic answer classification'
author: "Kirsten Stark"
date: "3/30/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load packages

```{r load_packages}
rm(list = ls())

library(tidyr)
library(dplyr)
library(stringr)
library(stringdist)

options( "encoding" = "UTF-8" )
```

## Load data

```{r load_data}
# input 
input = "data_long_final.csv"

# input synonym/alternative naming list
alternatives = "naming_alternatives.csv"

# load data
df <- read.csv(here::here("data", input))

# load alternatives
alternatives <- read.csv(here::here("data", alternatives), sep = ";")
```

## Define functions
### 1) Function to delete of last character typed words if those are space or enter

```{r function_delete_ending}
delete_ending <- function(word) {
  case_when(str_ends(word, " ") ~ str_sub(word, end=str_length(word)-1),
            str_ends(word, "Enter") ~ str_sub(word, end =str_length(word)-5),
            TRUE ~ word)
}
```

### 2) Replace special keys (e.g. backspace, shift, etc.) by numbers

```{r function_replace_special_chars}
replace_special_chars <- function(input, oldnames, newnames) {
  if(length(oldnames) != length(newnames)){
    print("Your oldname/newname vectors don't have the same length. Please correct!")
    stop()
  }
  for (i in 1:length(input)) {
    for (j in 1:length(oldnames)) {
      input[i] <- str_replace_all(input[i], pattern = oldnames[j], 
                        replacement = as.character(newnames[j]))
      if( i == 1) {
          print(paste0("The pattern ", oldnames[j], 
                   " has been replaced by the pattern ", 
                   newnames[j], ".", sep = ""))}
    }}
  return(input)
} 


```

### 3) Function that computes the final words by applying all backspaces

```{r function_replace_backspace}
replace_backspace <- function(input, backspace = "Backspace") {
  nletters = str_count(backspace)
  for(i in 1:length(input)) {
    backspaces <- str_locate_all(input[i], backspace)[[1]]
    for(j in 1:nrow(backspaces)){
      input[i] <- sub(str_c(".{1}",backspace), "", input[i])
    }
  }
  return(input)
}
```

### 4) Function that computes the fuzzy string matching
Calculate stringdistance between (backspace corrected) input word and item/alternative namings, and select the "best match", i.e. the item/alternative with the lowest distance and the first letter being correct.

```{r function_calculate_stringdist}
# alternatives should be a dataframe with col 1 = category, col 2 = item, col3...n = alternative1 ... alternativen
calculate_stringdist <- function(word, stims, alternatives = alternatives, method = "jw", firstlettercorrect = TRUE) { # ToDo: Check out JW options
  #word <- df$word.cb
  #stims <- df$item
  #alternatives <- alternatives
  #method = "jw"
 
  if(length(word) != length(stims)){
    print("Your typed words and item vectors don't have the same length. Please correct!")
    stop()
  }
  
  dist <- 1 # check out what the maximum value is for the other potential methods
  jw <- stringdist(toupper(word), toupper(stims), method = method)
  bestmatch <- stims
  for(i in 1:length(word)){
    #i = 26
    #print(i)
      
      if(toupper(stims[i]) %in% toupper(alternatives$item)) {
        for (j in 1:ncol(alternatives %>% 
                     dplyr:: select(starts_with("alternative")))) {
          #j = 1
          #print(j)
            currentalternative <- alternatives[
            toupper(alternatives$item) == toupper(stims[i]), j+2]
            if(!is.na(currentalternative) & !is.na(word[i])){
              if(currentalternative != "") {
                dist <- stringdist(toupper(word[i]), 
                                   toupper(currentalternative), method = "jw")}
              if(dist < jw[i] & !is.na(jw[i]) & !is.na(dist) & substring(
                toupper(word[i]),1,1) == substring(
                  toupper(currentalternative),1,1)) {
                jw[i] <- dist
                bestmatch[i] <- currentalternative
                dist <- 1
              }}
        }
      }}
  jwbest <- cbind(jw, bestmatch)
  return(jwbest)
#df$wordcorrected[df$jw < .30 & df$bestmatch != df$item]
}

```

### 5) Function that classifies the word entries

```{r classification_function}
case_character_type <- function(word, item, wordcorrected, jw, bestmatch, d) {
  case_when(
        
    # correct answers: participants typed exactly the correct word, 
    # with space or enter at the end
     toupper(word) == toupper(item) | 
       toupper(word) == toupper(str_c(item, " ")) |
       toupper(word) == toupper(str_c(item, "Enter")) ~ "correct",
     
    # correctedtocorrect: participants corrected their entry to the correct
    # word using "Backspace"
    (toupper(wordcorrected) == toupper(item) | 
       toupper(wordcorrected) == toupper(str_c(item, " ")) |
       toupper(wordcorrected) == toupper(str_c(item, "Enter"))) &
        substring(wordcorrected,1,1) == substring(word,1,1) &
        substring(word,2, 10) != "Backspace" ~ "correctedtocorrect",
    
    # alternative: jw limits needs to be set!
    (jw < d) & toupper(substring(wordcorrected,1,1)) ==
                  toupper(substring(bestmatch,1,1)) & 
      toupper(substring(word, 1,1)) == toupper(substring(bestmatch,1,1)) &
      substring(word,2, 10) != "Backspace" ~ "alternative",
       
    # backspace_space_enter: participants started by typing backspace, space,
    # enter, or capslock
     str_starts(word,"Backspace") |
       str_starts(word," ") |
       str_starts(word,"CapsLock") |
       str_starts(word,"Enter") ~ "backspace_space_enter",
    
    # shift_start: participants started by pressing the shift key
     str_starts(word,"Shift") ~ "shift_start",
    
    # isna: participants didn't enter anything
      is.na(word)       ~ "isna",
  
    # are all answers classified
    TRUE                      ~ "not_correct" )
}
```


## Preprocess data, applying functions
### 1) Clean word ending 
By deleting the last character(s) of typed words if those are space or enter keys

```{r clean_word_ending}
df <- df %>% mutate(word.c = delete_ending(df$word))
```

### 2) Replace special characters

```{r replace_special_chars}
oldnames <- c("Enter", "CapsLock", "Shift", "ArrowLeft", "ArrowRight", "Backspace")
newnames <- c("1", "2", "3", "4", "5", "6")
df$word.c2 <- replace_special_chars(input = df$word.c, oldnames = oldnames, newnames = newnames)
```

### 3) Compute finally submitted words by applying all backspaces

```{r replace_backspace}
#df$word.cb <- replace_backspace(df$word.c, backspace = "Backspace")
df$word.cb <- replace_backspace(df$word.c2, backspace = "6")
```

### 4) Compute stringdist between word entries and items/alternatives

```{r calculate_stringdist}
#stringdist(toupper(df$word.cb[1:200]), toupper(df$item[1:200]), method = "jw")
output <- calculate_stringdist(word = df$word.cb, stims = df$item, 
                               alternatives = alternatives, method = "jw",
                               firstlettercorrect = TRUE)
df$jw <- output[,1]
df$bestmatch <- output[,2]
```

### 5) Classify word entries

```{r classify_entries}
df2 <- df %>% mutate(answer_auto = case_character_type(
  word, item, word.cb, jw, bestmatch, d = 0.3))
```

### Inspect results

```{r}
table(df2$answer_auto)
df2 <- df2 %>% mutate(correct_auto = case_when(answer_auto == "alternative" ~ 1,
                                          answer_auto == "correct" ~ 1,
                                          answer_auto == "correctedtocorrect" ~ 1,
                                          TRUE ~ 0))
df2 <- df2 %>% mutate(correct_manual = case_when(answercode == "almostcorrect" ~ 1,
                                          answercode == "correct" ~ 1,
                                          TRUE ~ 0))
table(df2$correct_auto)
table(df2$correct_manual)
table(df2$correct_auto, df2$correct_manual)

new_incorrect <- cbind(item = df$item[
  df2$correct_auto == 0 & df2$correct_manual == 1],
                   word = df2$word[df2$correct_auto == 0 & df2$correct_manual == 1],
                   word.cb = df2$word.cb[df2$correct_auto == 0 & df2$correct_manual == 1],
                   jw = df2$jw[df2$correct_auto == 0 & df2$correct_manual == 1],
                   bestmatch = df2$bestmatch[
                     df2$correct_auto == 0 & df2$correct_manual == 1],
                   answer_auto = df2$answer_auto[
                     df2$correct_auto == 0 & df2$correct_manual == 1],
                    answercode = df2$answercode[
                     df2$correct_auto == 0 & df2$correct_manual == 1])
new_correct <- cbind(item = df2$item[df2$correct_auto == 1 & df2$correct_manual == 0],
                   word = df2$word[df2$correct_auto == 1 & df2$correct_manual == 0],
                   word.cb = df2$word.cb[df2$correct_auto == 1 & df2$correct_manual == 0],
                 jw= df2$jw[df2$correct_auto == 1 & df2$correct_manual == 0],
                 bestmatch = df2$bestmatch[df2$correct_auto == 1 & df2$correct_manual == 0])
```



```{r}
for (i in 1:length(unique(df2$type))) {
  print(paste(unique(df2$type)[i],"data collection: ", sep = " "))  
  print("Amount of trials classified as correct 
        (correct, correct with typos, synonymes")
  print(as.data.frame(table(df2$subject[df$type == unique(df2$type)[i]],
                      !is.na(df2$correct[df$type == unique(df2$type)[i]]))) %>%
    filter(Var2 == TRUE) %>%
    dplyr::rename(subject = Var1, totaltrials = Var2, correct = Freq) %>%
      mutate(totaltrials = 160) %>% 
      mutate(percentagecorrect = correct/totaltrials))
}
```
